%Simulate water waves on patches as an example of wave
%systems in the form h_t=u_x+... and u_u=h_x+...
%AJR, Nov 2017 -- Oct 2018
%!TEX root = ../Doc/eqnFreeDevMan.tex
%{
\section{\texttt{waterWaveExample}: simulate a water wave PDE on patches}
\label{sec:waterWaveExample}
\localtableofcontents

\cref{fig:ps1WaveCtsUH} shows an example simulation in time generated by the patch scheme function applied to a simple wave \pde.
The inter-patch coupling is realised by spectral interpolation to the patch edges of the mid-patch values.

This approach, based upon the differential equations coded in \cref{sec:simpleWavePDE}, may be adapted by a user to a wide variety of 1D wave and near-wave systems.
For example, the differential equations of \cref{sec:waterWavePDE} describes the nonlinear microscale simulator of the nonlinear shallow water wave \pde\ derived from the Smagorinski model of turbulent flow \cite[]{Cao2012, Cao2014b}.

\begin{devMan}
\begin{figure}
\centering \caption{\label{fig:ps1WaveCtsUH}water depth~\(h(x,t)\) (above) and velocity field~\(u(x,t)\) (below) of the gap-tooth scheme applied to the simple wave \pde~\cref{eq:genwaveqn}, linearised.
The microscale random component to the initial condition has long lasting effects on the simulation---but the macroscale wave still propagates.}
\includegraphics[scale=0.85]{Patch/ps1WaveCtsUH}
\end{figure}%
Often, wave-like systems are written in terms of two conjugate variables, for example, position and momentum density, electric and magnetic fields, and water depth~\(h(x,t)\) and mean lateral velocity~\(u(x,t)\) as herein.
The approach developed in this section applies to any wave-like system in the form
\begin{equation}
\D th=-c_1\D xu+f_1[h,u]
\quad\text{and}\quad
\D tu=-c_2\D xh+f_2[h,u],
\label{eq:genwaveqn}
\end{equation}
where the brackets indicate that the nonlinear functions~\(f_\ell\) may involve various spatial derivatives of the fields~\(h(x,t)\) and ~\(u(x,t)\).
For example, \cref{sec:waterWavePDE} encodes a nonlinear Smagorinski model of turbulent shallow water \cite[e.g.]{Cao2012, Cao2014b} along an inclined flat bed: let $x$~measure position along the bed and in terms of fluid depth~$h(x,t)$ and depth-averaged lateral velocity~$u(x,t)$ the model \pde{}s are
\begin{subequations}\label{eqs:patch:N}%
\begin{align}
\frac{\partial h}{\partial t}&=-\frac{\partial(hu)}{\partial x}\,,\label{patch:Nh}
\\
\frac{\partial u}{\partial t}&={}0.985\left(\tan\theta-\frac{\partial h}{\partial x}\right)-0.003\frac{u|u|}{h}-1.045u\frac{\partial u}{\partial x}+0.26h|u|\frac{\partial^2u}{\partial x^2}\,,\label{patch:Nu}
\end{align}
\end{subequations}
where~$\tan\theta$ is the slope of the bed.
Equation~\cref{patch:Nh} represents conservation of the fluid.
The momentum \pde~\cref{patch:Nu} represents  the effects of turbulent bed drag~$u|u|/h$, self-advection~$u\D xu$, nonlinear turbulent dispersion~$h|u|\DD xu$, and gravitational hydrostatic forcing~$\tan\theta-\D xh$.
\cref{fig:ps1WaterWaveCtsUH} shows one simulation of this system---for the same initial condition as \cref{fig:ps1WaveCtsUH}.

\begin{figure}
\centering \caption{\label{fig:ps1WaterWaveCtsUH}water depth~\(h(x,t)\) (above) and velocity field~\(u(x,t)\) (below) of the gap-tooth scheme applied to the Smagorinski shallow water wave \pde{}s~\cref{eqs:patch:N}.
The microscale random initial component decays where the water speed is non-zero due to `turbulent' dissipation.}
\includegraphics[scale=0.85]{Patch/ps1WaterWaveCtsUH}
\end{figure}%


For such wave systems, let's implement a staggered microscale grid and staggered macroscale patches as introduced by \cite{Cao2014a} in their Figures~3 and~4, respectively.




\subsection{Script code to simulate wave systems}
\label{sec:sc2waves}

This script implements the following gap-tooth scheme
(arrows indicate function recursion).
\begin{enumerate}\def\itemsep{-1.5ex}
\item configPatches1, and add micro-information 
\item ode15s \into patchSmooth1 \into simpleWavePDE
\item process results
\item ode15s \into patchSmooth1 \into waterWavePDE
\item process results
\end{enumerate}
Establish the global data struct~\verb|paches| for the \pde{}s~\cref{eq:genwaveqn} (linearised) solved on \(2\pi\)-periodic domain, with eight patches, each patch of half-size ratio~\(0.2\), with eleven points within each patch, and third-order interpolation to provide edge-values for the inter-patch coupling conditions (higher order interpolation is smoother for smooth initial conditions).
\begin{matlab}
%}
clear all
addpath('../Patch')
global patches
nPatch = 10
ratio = 0.2
nSubP = 11 %of the form 4*n-1
Len = 2*pi;
configPatches1(@simpleWavePDE,[0 Len],nan,nPatch,1,ratio,nSubP);
%{
\end{matlab}

Identify which microscale grid points are \(h\)~or~\(u\) values on the staggered micro-grid.
Also store the information in the struct~\verb|patches| for use by the time derivative function.
\begin{matlab}
%}
uPts = mod( bsxfun(@plus,(1:nSubP)',(1:nPatch)) ,2);
hPts = find(1-uPts);
uPts = find(uPts);
patches.hPts = hPts; patches.uPts = uPts;
%{
\end{matlab}

Set an initial condition of a progressive wave, and check evaluation of the time derivative.
The capital letter~\verb|U| denotes an array of values merged from both~\(u\) and~\(h\) fields on the staggered grids (possibly with some optional microscale wave noise).
\begin{matlab}
%}
U0 = zeros(nSubP,nPatch);
U0([1 end],:)=nan;
i=find(~isnan(U0));
%U0(hPts) = 1+0.5*sin(patches.x(hPts));
%U0(uPts) = 0+0.5*sin(patches.x(uPts));
%U0 = U0+0.02*randn(nSubP,nPatch);
%{
\end{matlab}
Now construct the Jacobian. Since linear wave \pde, use large perturbations.
\begin{matlab}
%}
small=1;
jac=nan(length(i));
sizejac=size(jac)
for j=1:length(i)
  U=U0(:);
  U(i(j))=U(i(j))+small;
  tmp=patchSmooth1(0,U)/small;
  jac(:,j)=tmp(i);
end
%{
\end{matlab}
Now explore the eigenvalues a little: find the ten with the biggest real-part; if small enough, then the method may be good.
\begin{matlab}
%}
[evecs,evals]=eig(jac);
evals=diag(evals);
nEvals=length(evals)
[~,k]=sort(-abs(real(evals)));
evalsWithBiggestRealPart=evals(k(1:10))
if abs(real(evals(k(1))))>1e-4
    warning('eigenvalue failure: real-part > 1e-4')
    return, end
%{
\end{matlab}
Cluster the frequencies.
\begin{matlab}
%}
[freqs,j]=sort(imag(evals));
icl=clusterdata(freqs,nSubP-2);
freqcl=[];
for j=1:nSubP-2,freqcl(j,:)=[mean(freqs(icl==j)),std(freqs(icl==j))], end
%{
\end{matlab}
Explore a high-frequency cluster-space with sparse PCA: appears that such modes are effectively confined to a patch and its nearest pair of neighbours!
\begin{matlab}
%}
[~,j]=max(freqcl(:,1))
j=find(abs(evals-1i*freqcl(j,1))<3*freqcl(j,2))
V=evecs(:,j);
small=1e-7;
S=spcart(V+small*(randn(size(V))+1i*randn(size(V))));
S=real(S).*(abs(real(S))>20*small)+1i*imag(S).*(abs(imag(S))>20*small);
Spat=reshape(S,nSubP-2,nPatch,nPatch);
nNonzeroElems=sum(abs(S)>small)
normNonSpan=norm( S*(S\V)-V )
%{
\end{matlab}




\subsection{\texttt{simpleWavePDE()}: simple wave PDE}
\label{sec:simpleWavePDE}
This function codes the staggered lattice equation inside the patches for the simple wave \pde\ system \(h_t=-u_x\) and \(u_t=-h_x\).
Here code for a staggered microscale grid of staggered macroscale patches: the array
\begin{equation*}
U_{ij}=\begin{cases} u_{ij}&i+j\text{ even},\\
h_{ij}& i+j\text{ odd}.
\end{cases}
\end{equation*}
The output~\verb|Ut| contains the merged time derivatives of the two staggered fields.
So set the micro-grid spacing and reserve space for time derivatives.
\begin{matlab}
%}
function Ut = simpleWavePDE(t,U,x)
  global patches
  dx = diff(x(2:3));
  Ut = nan(size(U));  ht = Ut;
%{
\end{matlab}
Compute the \pde\ derivatives at interior points of the patches.
\begin{matlab}
%}
  i = 2:size(U,1)-1;
%{
\end{matlab}
Here `wastefully' compute time derivatives for both \pde{}s at all grid points---for `simplicity'---and then merges the staggered results.
Since \(\dot h_{ij} \approx-(u_{i+1,j}-u_{i-1,j})/(2\cdot dx) =-(U_{i+1,j}-U_{i-1,j})/(2\cdot dx)\) as adding\slash subtracting one from the index of a \(h\)-value is the location of the neighbouring \(u\)-value on the staggered micro-grid.
\begin{matlab}
%}
  ht(i,:) = -(U(i+1,:)-U(i-1,:))/(2*dx);
%{
\end{matlab}
Since \(\dot u_{ij} \approx-(h_{i+1,j}-h_{i-1,j})/(2\cdot dx) =-(U_{i+1,j}-U_{i-1,j})/(2\cdot dx)\) as adding\slash subtracting one from the index of a \(u\)-value is the location of the neighbouring \(h\)-value on the staggered micro-grid.
\begin{matlab}
%}
  Ut(i,:) = -(U(i+1,:)-U(i-1,:))/(2*dx);
%{
\end{matlab}
Then overwrite the unwanted~\(\dot u_{ij}\) with the corresponding wanted~\(\dot h_{ij}\).
\begin{matlab}
%}
  Ut(patches.hPts) = ht(patches.hPts);
end
%{
\end{matlab}



\subsection{\texttt{waterWavePDE()}: water wave PDE}
\label{sec:waterWavePDE}
This function codes the staggered lattice equation inside the patches for the nonlinear wave-like \pde\ system~\cref{eqs:patch:N}.
Also, regularise the absolute value appearing the the \pde{}s via the one-line function~\verb|rabs()|.
\begin{matlab}
%}
function Ut = waterWavePDE(t,U,x)
  global patches
  rabs = @(u) sqrt(1e-4+u.^2);
%{
\end{matlab}
As before, set the micro-grid spacing, reserve space for time derivatives, and index the patch-interior points of the micro-grid.
\begin{matlab}
%}
  dx = diff(x(2:3));
  Ut = nan(size(U));  ht = Ut;
  i = 2:size(U,1)-1;
%{
\end{matlab}
Need to estimate~\(h\) at all the \(u\)-points, so  into~\verb|V| use averages, and linear extrapolation to patch-edges.
\begin{matlab}
%}
  ii = i(2:end-1);
  V = Ut;
  V(ii,:) = (U(ii+1,:)+U(ii-1,:))/2;
  V(1:2,:) = 2*U(2:3,:)-V(3:4,:);
  V(end-1:end,:) = 2*U(end-2:end-1,:)-V(end-3:end-2,:);
%{
\end{matlab}
Then estimate \(\D x{(hu)}\) from~\(u\) and the interpolated~\(h\) at the neighbouring micro-grid points.
\begin{matlab}
%}
  ht(i,:) = -(U(i+1,:).*V(i+1,:)-U(i-1,:).*V(i+1,:))/(2*dx);
%{
\end{matlab}
Correspondingly estimate the terms in the momentum \pde: \(u\)-values in~\(\verb|U|_i\) and~\(\verb|V|_{i\pm1}\); and \(h\)-values in~\(\verb|V|_i\) and~\(\verb|U|_{i\pm1}\).
\begin{matlab}
%}
  Ut(i,:) = -0.985*(U(i+1,:)-U(i-1,:))/(2*dx) ...
    -0.003*U(i,:).*rabs(U(i,:)./V(i,:)) ...
    -1.045*U(i,:).*(V(i+1,:)-V(i-1,:))/(2*dx) ...
    +0.26*rabs(V(i,:).*U(i,:)).*(V(i+1,:)-2*U(i,:)+V(i-1,:))/dx^2/2;
%{
\end{matlab}
where the mysterious division by two in the second derivative is due to using the averaged values of~\(u\) in the estimate:
\begin{eqnarray*}
u_{xx}&\approx&\frac1{4\delta^2}(u_{i-2}-2u_i+u_{i+2})
\\&=&\frac1{4\delta^2}(u_{i-2}+u_i-4u_i+u_i+u_{i+2})
\\&=&\frac1{2\delta^2}\left(\frac{u_{i-2}+u_i}2-2u_i+\frac{u_i+u_{i+2}}2\right)
\\&=&\frac1{2\delta^2}\left(\bar u_{i-1}-2u_i+\bar u_{i+1}\right).
\end{eqnarray*}
Then overwrite the unwanted~\(\dot u_{ij}\) with the corresponding wanted~\(\dot h_{ij}\).
\begin{matlab}
%}
  Ut(patches.hPts) = ht(patches.hPts);
end
%{
\end{matlab}
Fin.
\end{devMan}
%}
