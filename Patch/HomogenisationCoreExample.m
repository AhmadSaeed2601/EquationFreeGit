% Simulate heterogeneous diffusion in 1D on patches as an
% example application of patches in space, 
% with macroscale determined from a core average.
% AJR, Nov 2017 -- Oct 2018; JEB Nov 2018
%!TEX root = ../Doc/equationFreeDoc.tex
%{
\subsection[\texttt{HomogenisationCoreExample}: simulate heterogeneous diffusion in 1D \ldots]{\texttt{HomogenisationCoreExample}: simulate heterogeneous diffusion in 1D on patches}
\label{sec:HomogenisationCoreExample}
\localtableofcontents

\cref{fig:ps1HomogenisationCoreCtsU} and \cref{fig:ps1HomogenisationCoreCtsUEnsAve} 
show example simulations in time generated by the patch scheme function applied to
heterogeneous diffusion without and with an ensemble average, respectively. 
That such simulations of
heterogeneous diffusion makes valid predictions was
established by \cite{Bunder2013b} who proved that the scheme
is accurate when the number of points in a patch minus the number of points
in the core is an even multiple of the microscale periodicity (assuming the
microscale periodicity is periodic on the macroscale domain).

We present two different methods of optaining a macroscale solution.
One method uses the given heterogeneous diffusion, which produces a
solution which is rough at the microscale. The other method constructs an
ensemble of heterogeneous diffusion an produces an ensemble average 
solution which is smooth at the microscale. 

The first part of the script implements the following gap-tooth scheme
(arrows indicate function recursion).
\begin{enumerate}\def\itemsep{-1.5ex}
\item configPatches1 
\item ode15s \into patchSmooth1 \into heteroDiff
\item process results
\end{enumerate}

\begin{body}
\begin{figure}
\centering \caption{\label{fig:ps1HomogenisationCoreCtsU}the
diffusing field~\(u(x,t)\) in the patch (gap-tooth) scheme
applied to microscale heterogeneous diffusion with no ensemble average.}
\includegraphics[scale=0.85]{../Patch/ps1HomogenisationCoreCtsU}
\end{figure}%
\begin{figure}
\centering \caption{\label{fig:ps1HomogenisationCoreCtsUEnsAve}the
diffusing field~\(u(x,t)\) in the patch (gap-tooth) scheme
applied to microscale heterogeneous diffusion with an ensemble average.}
\includegraphics[scale=0.85]{../Patch/ps1HomogenisationCoreCtsUEnsAve}
\end{figure}%

Consider a lattice of values~\(u_i(t)\), with lattice
spacing~\(dx\), and governed by the heterogeneous diffusion 
\begin{equation}
\dot u_i=[c_{i-1/2}(u_{i-1}-u_i)+c_{i+1/2}(u_{i+1}-u_i)]/dx^2.
\label{eq:HomogenisationCoreExample}
\end{equation}
In this 1D space, the macroscale, homogenised, effective
diffusion should be the harmonic mean of these coefficients.


\subsubsection{Script to simulate via stiff or projective integration}
Set the desired microscale periodicity, and microscale
diffusion coefficients (with subscripts shifted by a half).
%The periodicity \verb|mPeriod| should evenly divide the total number of 
%microscale lattice points across the macroscale domain 
%\(\verb|(nSubP-1)*nPatch/(2*ratio)|\).
\begin{matlab}
%}
clear all
mPeriod = 4

rng('default'); rng(1);
sc=4;
cDiff = exp(sc*rand(mPeriod,1)); %2*abs(randn(mPeriod,1)); %exp(randn(mPeriod,1)); %2*abs(randn(mPeriod,1)); % 
cHomo = max(cDiff); %1/mean(1./cDiff);
%{
\end{matlab}

Establish global data struct for heterogeneous diffusion
solved on \(2\pi\)-periodic domain, with eleven patches, each
patch with half-size ratio~\(0.2\), and the number of points in a
patch minus the number of patches in a core equal to an
even multiple of the microscale periodicity (which \cite{Bunder2013b} 
showed is accurate).
Quadratic (fourth-order) interpolation provides values for
the inter-patch coupling conditions.
\begin{matlab}
%}
global patches
nPatch = 11
ratio = 0.2
nSubP = 11
Len = 2*pi;
configPatches1(@heteroDiff,[0 Len],nan,nPatch,4,ratio,nSubP);
%{
\end{matlab}

A user can add information to the global data
struct~\verb|patches| in order to communicate to the time
derivative function. 
A \((\verb|nSubP-1)|\times \verb|nPatch|\) matrix defines 
the diffusivity coefficients within each patch, but with ensemble averaging
this must be increase to \((\verb|nSubP-1)|\times \verb|nPatch|\times \verb|nVars|\) 
(that is, when ensemble averaging \verb|nVars| is the size of the ensemble;
when we have no ensemble averaging \verb|nVars| is the number of different 
field variables). 
The odd integer \(\verb|patches.nCore|=3\) defines the size of the patch core 
(this must be larger than zero and less than \verb|nSubP|), where 
a core of size zero indicates that the value in the centre of the patch is the 
macroscale. 
The introduction of a patch requires a redefinition of the half-patch
ratio, as described by \cite{Bunder2013b}.
We evaluate the patch coupling by interpolating the core and 
ensemble averaged field (although the latter only when 
\(\verb|patches.Ens|=1\)).
\begin{matlab}
%}
patches.ordCC=6;
patches.cDiff = cDiff((mod(round(patches.x(1:(end-1),:)/(patches.x(2)-patches.x(1))-0.5),mPeriod)+1));
patches.nCore=3; %3
patches.ratio = ratio*(nSubP - patches.nCore)/(nSubP - 1);
%{
\end{matlab}

The Boolean \verb|patches.Ens| indicates whether or
not we apply ensemble averaging of diffusivity configurations; if we do, 
then \verb|nVars| becomes the size of the ensemble. When ensemble averaging 
we use the ensemble described by \cite{Bunder2013b} which includes all 
reflected and translated configurations of \verb|patches.cDiff|.
\begin{matlab}
%}
patches.EnsAve=1;
if patches.EnsAve    
  if mPeriod>2
    nVars=2*mPeriod;
  else
    nVars=mPeriod;
  end
  patches.cDiff=repmat(patches.cDiff,[1,1,nVars]);    
  for sx=2:mPeriod
    patches.cDiff(:,:,sx)=circshift(patches.cDiff(:,:,sx-1),[sx-1,0]);
   end;
   if nVars>2
     patches.cDiff(:,:,(mPeriod+1):end)=flipud(patches.cDiff(:,:,1:mPeriod)); 
   end;
end
%{
\end{matlab}

\paragraph{Conventional integration in time}
Set an initial condition, and here integrate forward in time
using a standard method for stiff systems---because of the
simplicity of linear problems this method works quite
efficiently here.  Integrate the interface
\verb|patchSmooth1| (\cref{sec:patchSmooth1}) to the
microscale differential equations. 
\begin{matlab}
%}
u0 = sin(patches.x)+0.2*randn(nSubP,nPatch);
if patches.EnsAve
  u0 = repmat(u0,[1,1,nVars]);
end
[ts,ucts] = ode15s(@patchCoreSmooth1, [0 2/cHomo], u0(:));
ucts=reshape(ucts,length(ts),length(patches.x(:)),[]);
%{
\end{matlab}

Plot the simulation in \cref{fig:ps1HomogenisationCoreCtsU} (with no ensemble average) or \cref{fig:ps1HomogenisationCoreCtsUEnsAve} (with an ensemble average).
If we have calculated an ensemble of field solutions, we must first take
the ensemble average. 
\begin{matlab}
%}
if patches.EnsAve % calculate the ensemble average
  uctsAve=mean(ucts,3);
else
  uctsAve=ucts;
end
figure(1),clf
xs = patches.x;  xs([1 end],:) = nan;
mesh(ts,xs(:),uctsAve'),  view(60,40)
xlabel('time t'), ylabel('space x'), zlabel('u(x,t)')
set(gcf,'paperposition',[0 0 7 5])
if patches.EnsAve
  print('-depsc2','ps1HomogenisationCoreCtsUEnsAve')
else
  print('-depsc2','ps1HomogenisationCoreCtsU')
end
%{
\end{matlab}

\paragraph{Use projective integration in time}
\begin{figure}
\centering \caption{\label{fig:ps1HomogenisationCoreU}field
\(u(x,t)\) shows basic projective integration of patches of
heterogeneous diffusion with no ensemble average.}
\includegraphics[scale=0.85]{../Patch/ps1HomogenisationCoreU}
\end{figure}%
\begin{figure}
\centering \caption{\label{fig:ps1HomogenisationCoreUEnsAve}field
\(u(x,t)\) shows basic projective integration of patches of
heterogeneous diffusion with an ensemble average.}
\includegraphics[scale=0.85]{../Patch/ps1HomogenisationCoreUEnsAve}
\end{figure}%

Now take \verb|patchSmooth1|, the interface to the time
derivatives, and wrap around it the projective integration
\verb|PIRK2| (\cref{sec:PIRK2}), of bursts of simulation
from \verb|heteroBurst| (\cref{sec:heteroBurst}), as
illustrated by \cref{fig:ps1HomogenisationCoreU} and  \cref{fig:ps1HomogenisationCoreUEnsAve}.

This second part of the script implements the following design, where the 
micro-integrator could be, for example, \verb|ode23| or \verb|rk2int|.
\begin{enumerate} \def\itemsep{-1.5ex}
\item configPatches1 (done in first part)
\item PIRK2 \into heteroBurst \into micro-integrator \into patchSmooth1 
\into heteroDiff
\item process results
\end{enumerate}

Mark that edge of patches are not to be used in the
projective extrapolation by setting initial values to \nan.
\begin{matlab}
%}
u0([1 end],:) = nan;
%{
\end{matlab}
Set the desired macro- and micro-scale time-steps over the
time domain: the macroscale step is in proportion to the
effective mean diffusion time on the macroscale; the burst
time is proportional to the intra-patch effective diffusion
time; and lastly, the microscale time-step is proportional
to the diffusion time between adjacent points in the
microscale lattice.
\begin{matlab}
%}
ts = linspace(0,2/cHomo,7)
bT = 3*( ratio*Len/nPatch )^2/cHomo
addpath('../ProjInt','../RKint')
[us,tss,uss] = PIRK2(@heteroBurst, bT, ts, u0(:));
%{
\end{matlab}
Plot the macroscale predictions to draw
\cref{fig:ps1HomogenisationCoreU} or \cref{fig:ps1HomogenisationCoreUEnsAve}.
If we have calculated an ensemble of field solutions, we must first take
the ensemble average. 
\begin{matlab}
%}
if patches.EnsAve % calculate the ensemble average
  usAve=mean(reshape(us,size(us,1),length(xs(:)),nVars),3); 
  ussAve=mean(reshape(uss,length(tss),length(xs(:)),nVars),3);
else
  usAve=us;
  ussAve=uss;
end
figure(2),clf
plot(xs(:),usAve','.')
ylabel('u(x,t)'), xlabel('space x')
legend(num2str(ts',3))
set(gcf,'paperposition',[0 0 7 5])
if patches.EnsAve
  print('-depsc2','ps1HomogenisationCoreUEnsAve')
else
  print('-depsc2','ps1HomogenisationCoreU')
end
%{
\end{matlab}
Also plot a surface detailing the microscale bursts as shown
in \cref{fig:ps1HomogenisationCoreMicro} or \cref{fig:ps1HomogenisationCoreMicroEnsAve}.
\begin{figure}
\centering \caption{\label{fig:ps1HomogenisationCoreMicro}stereo
pair of the field~\(u(x,t)\) during each of the microscale
bursts used in the projective integration with no ensemble averaging.}
\includegraphics[scale=0.85]{../Patch/ps1HomogenisationCoreMicro}
\end{figure}
\begin{figure}
\centering \caption{\label{fig:ps1HomogenisationCoreMicroEnsAve}stereo
pair of the field~\(u(x,t)\) during each of the microscale
bursts used in the projective integration with ensemble averaging.}
\includegraphics[scale=0.85]{../Patch/ps1HomogenisationCoreMicro}
\end{figure}

\begin{matlab}
%}
figure(3),clf
for k = 1:2, subplot(2,2,k)
  surf(tss,xs(:),ussAve',  'EdgeColor','none')
  ylabel('x'), xlabel('t'), zlabel('u(x,t)')
  axis tight, view(126-4*k,45)
end
set(gcf,'paperposition',[0 0 7 5])
if patches.EnsAve
  print('-depsc2','ps1HomogenisationCoreMicroEnsAve')
else
  print('-depsc2','ps1HomogenisationCoreMicro')
end
%{
\end{matlab}
End of the script.

\subsubsection{\texttt{heteroDiff()}: heterogeneous diffusion}
\label{sec:heteroDiff}
This function codes the lattice heterogeneous diffusion
inside the patches.  For 2D input arrays~\verb|u|
and~\verb|x| (via edge-value interpolation of
\verb|patchSmooth1|, \cref{sec:patchSmooth1}), computes the
time derivative~\cref{eq:HomogenisationCoreExample} at each
point in the interior of a patch, output in~\verb|ut|.  The
column vector (or possibly array) of diffusion
coefficients~\(c_i\) have previously been stored in
struct~\verb|patches|.
\begin{matlab}
%}
function ut = heteroDiff(t,u,x)  
  global patches
  dx = diff(x(2:3)); % space step
  i = 2:size(u,1)-1; % interior points in a patch
  ut = nan(size(u)); % preallocate output array
  ut(i,:,:) = diff(patches.cDiff.*diff(u))/dx^2; %- abs(u(i,:,:)).*u(i,:,:).^2;
end
%{
\end{matlab}

\subsubsection{\texttt{heteroBurst()}: a burst of heterogeneous diffusion}
\label{sec:heteroBurst}
This code integrates in time the derivatives computed by
\verb|heteroDiff| from within the patch coupling of
\verb|patchSmooth1|.  Try three possibilities:
\begin{itemize}
\item \verb|ode23| generates `noise' that is unsightly at
best and may be ruinous;
\item \verb|ode15s| does not cater for the \nan{}s in some
components of~\verb|u|;
\item \verb|rk2int| simple specified step integrator behaves
consistently, and so appears best.
\end{itemize}
\begin{matlab}
%}
function [ts, ucts] = heteroBurst(ti, ui, bT) 
  switch 'rk2'
  case '23',  [ts,ucts] = ode23 (@patchCoreSmooth1,[ti ti+bT],ui(:));
  case '15s', [ts,ucts] = ode15s(@patchCoreSmooth1,[ti ti+bT],ui(:));
  case 'rk2', ts = linspace(ti,ti+bT,200)';
              ucts = rk2int(@patchCoreSmooth1,ts,ui(:));
  end
end 
%{
\end{matlab}
Fin.
\end{body}
%}
