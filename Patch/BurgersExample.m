% Simulate a microscale space-time map of Burgers' PDE
% discretised.  Simulate on spatial patches and via
% projective integration.
% AJR, Nov 2017 -- Oct 2018
%!TEX root = ../Doc/equationFreeDoc.tex
%{
\subsection{\texttt{BurgersExample}: simulate Burgers' PDE on patches}
\label{sec:BurgersExample}
\localtableofcontents

\cref{fig:ps1BurgersCtsU} shows an example simulation in
time generated by the patch scheme function applied to
Burgers' \pde. This code similarly applies the Equation-Free
functions to a microscale space-time map
(\cref{fig:ps1BurgersMapU}), a map that happens to be
derived as a micro-scale space-time discretisation of
Burgers'~\pde.  Then this example applies projective
integration to simulate further in time.

The first part of the script implements the following gap-tooth scheme 
(arrows indicate function recursion).
\begin{enumerate}\def\itemsep{-1.5ex}
\item configPatches1 
\item burgerBurst \into patchSmooth1 \into burgersMap
\item process results
\end{enumerate}

\begin{body}
\begin{figure}
\centering \caption{\label{fig:ps1BurgersMapU}a short time
simulation of the Burgers' map (\cref{sec:burgersMap}) on
patches in space. It requires many very small time steps
only just visible in this mesh.}
\includegraphics[scale=0.85]{../Patch/ps1BurgersMapU}
\end{figure}%


\subsubsection{Script code to simulate a micro-scale space-time map}

Establish global data struct for the Burgers' map
(\cref{sec:burgersMap}) solved on \(2\pi\)-periodic domain,
with eight patches, each patch of half-size ratio~\(0.2\), 
with seven points within each patch, and say fourth order
interpolation provides edge-values that couple the patches.
\begin{matlab}
%}
clear all
global patches
nPatch = 8
ratio = 0.2
nSubP = 7
interpOrd = 4
Len = 2*pi
configPatches1(@burgersMap,[0 Len],nan,nPatch,interpOrd,ratio,nSubP);
%{
\end{matlab}
Set an initial condition, and simulate a burst of the
micro-scale space-time map over a time~\(0.2\) using the
function \verb|burgerBurst()| (\cref{sec:burgerBurst}).
\begin{matlab}
%}
u0 = 0.4*(1+sin(patches.x))+0.1*randn(size(patches.x));
[ts,us] = burgerBurst(0,u0,0.2);
%{
\end{matlab}
Plot the simulation. Use only the microscale values interior
to the patches via \verb|nan| in the \(x\)-edges to leave
gaps.
\begin{matlab}
%}
figure(1),clf
xs = patches.x;  xs([1 end],:) = nan;
mesh(ts,xs(:),us')
xlabel('time t'), ylabel('space x'), zlabel('u(x,t)')
view(105,45)
set(gcf,'paperposition',[0 0 14 10])
print('-depsc2','ps1BurgersMapU')
%{
\end{matlab}



\paragraph{Use projective integration}
\begin{figure}
\centering \caption{\label{fig:ps1BurgersU}macro-scale
space-time field \(u(x,t)\) in a basic projective
integration of the patch scheme applied to the micro-scale
Burgers' map.}
\includegraphics[scale=0.85]{../Patch/ps1BurgersU}
\end{figure}%
Around the micro-scale burst \verb|burgerBurst()|, wrap the
projective integration function \verb|PIRK2()| of
\cref{sec:PIRK2}. \cref{fig:ps1BurgersU} shows the
macroscale prediction of the patch centre values on
macro-scale time-steps.

This second part of the script implements the following design.
\begin{enumerate} \def\itemsep{-1.5ex}
\item configPatches1 (done in first part)
\item PIRK2 \into burgerBurst \into patchSmooth1 \into burgersMap
\item process results
\end{enumerate}


Mark that edge of patches are not to be used in the
projective extrapolation by setting initial values to \nan.
\begin{matlab}
%}
u0([1 end],:) = nan;
%{
\end{matlab}
Set the desired macro-scale time-steps, and micro-scale
burst length over the time domain.  Then projectively
integrate in time using \verb|PIRK2()| which is (roughly)
second-order accurate in the macro-scale time-step.
\begin{matlab}
%}
ts = linspace(0,0.5,11);
bT = 3*(ratio*Len/nPatch/(nSubP/2-1))^2
addpath('../ProjInt')
[us,tss,uss] = PIRK2(@burgerBurst,bT,ts,u0(:));
%{
\end{matlab}
Plot the macroscale predictions of the mid-patch values to
give the macroscale mesh of \cref{fig:ps1BurgersU}.
\begin{matlab}
%}
figure(2),clf
mid = (nSubP+1)/2;
mesh(ts,xs(mid,:),us(:,mid:nSubP:end)')
xlabel('time t'), ylabel('space x'), zlabel('u(x,t)')
view(120,50)
set(gcf,'paperposition',[0 0 14 10])
print('-depsc2','ps1BurgersU')
%{
\end{matlab}
Then plot the microscale mesh of the microscale bursts shown
in \cref{fig:ps1BurgersMicro} (a stereo pair).  The details
of the fine microscale mesh are almost invisible.
\begin{figure}
\centering \caption{\label{fig:ps1BurgersMicro}the field
\(u(x,t)\) during each of the microscale bursts used in the
projective integration.  View this stereo pair cross-eyed.}
\includegraphics[scale=0.85]{../Patch/ps1BurgersMicro}
\end{figure}
\begin{matlab}
%}
figure(3),clf
for k = 1:2, subplot(2,2,k)
  mesh(tss,xs(:),uss')
  ylabel('x'),xlabel('t'),zlabel('u(x,t)')
  axis tight, view(126-4*k,50)
end
set(gcf,'paperposition',[0 0 17 12])
print('-depsc2','ps1BurgersMicro')
%{
\end{matlab}






\subsubsection{\texttt{burgersMap()}: discretise the PDE microscale}
\label{sec:burgersMap}
This function codes the microscale Euler integration map of
the lattice differential equations inside the patches.  Only
the patch-interior values mapped (\verb|patchSmooth1|
overrides the edge-values anyway).
\begin{matlab}
%}
function u = burgersMap(t,u,x)
  dx = diff(x(2:3));   dt = dx^2/2;
  i = 2:size(u,1)-1;
  u(i,:) = u(i,:) +dt*( diff(u,2)/dx^2 ...
     -20*u(i,:).*(u(i+1,:)-u(i-1,:))/(2*dx) );
end
%{
\end{matlab}



\subsubsection{\texttt{burgerBurst()}: code a burst of the patch map}
\label{sec:burgerBurst}
\begin{matlab}
%}
function [ts, us] = burgerBurst(ti, ui, bT) 
%{
\end{matlab}
First find and set the number of micro-scale time-steps.
\begin{matlab}
%}
  global patches
  dt = diff(patches.x(2:3))^2/2;
  ndt = ceil(bT/dt -0.2);
  ts = ti+(0:ndt)'*dt;
%{
\end{matlab}
Apply the microscale map over all time-steps in the burst,
using \verb|patchSmooth1| (\cref{sec:patchSmooth1}) as the
interface that provides the interpolated edge-values of each
patch.  Store the results in rows to be consistent with
\ode\ and projective integrators.
\begin{matlab}
%}
  us = nan(ndt+1,numel(ui)); 
  us(1,:) = reshape(ui,1,[]);
  for j = 1:ndt
    ui = patchSmooth1(ts(j),ui);
    us(j+1,:) = reshape(ui,1,[]);
  end
%{
\end{matlab}
Linearly interpolate (extrapolate) to get the field values
at the precise final time of the burst.  Then return.
\begin{matlab}
%}
  ts(ndt+1) = ti+bT;
  us(ndt+1,:) = us(ndt,:) ...
    + diff(ts(ndt:ndt+1))/dt*diff(us(ndt:ndt+1,:));
end
%{
\end{matlab}
Fin.
\end{body}
%}
