%Initially by AJR, Apr 2017 -- Nov 2018
%!TEX root = eqnFreeDevMan.tex
\chapter{Introduction}
%\localtableofcontents

\begin{devMan}
This Developers Manual contains complete descriptions of the code in each function in the toolbox, and each example.  For concise descriptions of each function, quick start guides, and some basic examples, see the User Manual.
\end{devMan}


\paragraph{Users}
Place the folder of this toolbox in a path searched by \script.
Then read the section(s) that documents the function of interest.


\paragraph{Quick start}
Maybe start by adapting one of the included examples. Many of the main functions include, at their start, example code of their use (code which is executed if the function is invoked without any arguments).
\begin{itemize}
\item To projectively integrate over time a multiscale, slow-fast, system of \ode{}s you could use \verb|PIRK2()|: adapt the Michaelis--Menten example at the start of \verb|PIRK2.m| (\cref{sec:pirk2eg}).
\item You may use forward bursts of simulation in order to simulate the slow dynamics backward in time, as in \verb|egPIMM.m| (\cref{sec:egPIMM}).
\item To only resolve the slow dynamics in the projective integration, use lifting and restriction functions by adapting the singular perturbation \ode\ example at the start of \verb|PIG.m| (\cref{sec:pigeg}).
\item Consider an evolving system over a large spatial domains when all you have is a microscale code.  To efficiently simulate over the large domain, one can simulate in just small patches of the domain, appropriately coupled:
\begin{itemize}
\item in 1D adapt the code at the start of \verb|configPatches1.m| for Burgers' \pde\ (\cref{sec:configPatches1eg})%
\ifcsname r@sec:wave2D\endcsname, or the staggered patches of 1D water wave equations in \verb|waterWaveExample.m| (\cref{sec:waterWaveExample})\fi;
\item in 2D adapt the code at the start of \verb|configPatches2.m| for nonlinear diffusion (\cref{sec:configPatches2eg})%
\ifcsname r@sec:wave2D\endcsname, or the regular patches of the 2D wave equation of \verb|wave2D.m| (\cref{sec:wave2D})\fi.
\end{itemize}
\item The above are for systems that have \emph{smooth} spatial structures on the microscale: when the microscale is `rough' with a known period (so far only in 1D), then adapt 
the example of \verb|HomogenisationExample.m| (\cref{sec:HomogenisationExample}).
\end{itemize}


\paragraph{Blackbox scenario}
Assume that a researcher\slash practitioner has a detailed and \emph{trustworthy} computational simulation of some problem of interest.
Let's say the simulation is coded in terms of micro-field variable values~\(\uv_i(t)\) for indices~\(i\) in some (large) set of integers, and for time~\(t\).
Perhaps the indices~\(i\) correspond to `spatial' coordinates~\(\xv_i(t)\).
In lattice problems the positions~\(\xv_i\) would be fixed in time (unless employing a moving mesh on the microscale); in particle problems the positions would evolve.
The positional coordinates are \(\xv_i\in\RR^{d}\) where for spatial problems integer \(d=1,2,3\), but it may be more when solving for a distribution of velocities, or pore sizes, or trader's beliefs, etc.
The micro-field variables could be in~\(\RR^{p}\) for any \(p=1,2,\ldots,\infty\).
Further, assume that the computational simulation is too expensive over all the desired spatial domain~\(\XX\subset\RR^{d}\).
Thus we aim a toolbox to simulate only on macroscale distributed patches.



\paragraph{Contributors}
The aim of this project is to collectively develop a \script\ toolbox of equation-free algorithms.
Initially the algorithms are basic, and the plan is to subsequently develop more and more capability.

\textsc{Matlab} appears a good choice for a first version since it is widespread, efficient, supports various parallel modes, and development costs are reasonably low.
Further it is built on \textsc{blas} and \textsc{lapack} so the cache and superscalar \cpu{} are potentially well utilised.
We aim to develop functions that work for~\script.
\ifcsname r@sec:contribute\endcsname\cref{sec:contribute} outlines some details for contributors.\fi


\newlength{\WD}% set overall size for each chart, propto linewidth
\begin{figure}
\caption{\label{fig:constructPI}The Projective Integration method greatly accelerates simulation\slash integration of a system exhibiting multiple time scales.
The Projective Integration \cref{sec:ProjInt} presents several separate functions, as well as several optional wrapper functions that may be invoked. 
This chart overviews constructing a Projective Integration simulation, whereas \cref{fig:PIchoosemacro} roughly guides which top-level Projective Integration functions should be used.
\cref{sec:ProjInt} fully details each function.}
\centering
\setlength{\WD}{0.05\linewidth}%%%%%%%%%%%%%%%%
\begin{tikzpicture}[node distance = 3ex, auto]
\tikzstyle{bigblock} = [rectangle, draw, thick,   text width=20.5\WD, text badly centered,
    rounded corners, minimum height=4ex]
\tikzstyle{block} = [rectangle, draw=red!80!black, thick, anchor=west, fill=white,
    text width=9.6\WD, text ragged, rounded corners, minimum height=8ex]
 \tikzstyle{smallblock} = [rectangle, draw=red!80!black, thick, anchor=west, fill=white,
    text width=6\WD, text ragged, rounded corners, minimum height=8ex]   
 \tikzstyle{tinyblock} = [rectangle, draw=red!80!black, thick, anchor=west, fill=white,
    text width=4.3\WD, text ragged, rounded corners, minimum height=8ex]    
     \tikzstyle{smallenclose} = [rectangle, draw=red!80!black, thick, anchor=west, fill=white,
    text width=6.2\WD, text ragged, rounded corners, minimum height=8ex]   
     \tikzstyle{refblock} = [rectangle, draw=blue!80!black, thick, anchor=west, fill=blue!5,
    text width=1\WD, rounded corners, minimum height=1.05em] 
\tikzstyle{line} = [draw, -latex']
\tikzstyle{lined} = [draw, latex'-latex']
\node [bigblock,draw=red!80!black,fill=red!10] (gaptooth) {\textbf{Schematic for Projective Integration scheme}

    \begin{tikzpicture}[node distance = 3ex, auto]
    \node [block] (setmicro) {\textbf{Set microsolver}
     
    Define or construct the function \texttt{solver()} that calls a black-box microsolver. Set \texttt{bT}, the time to run microsolver for. Possible aids:
\begin{itemize}
\item     Use the Patch functions (\cref{fig:constructpatch}) to simulate a large-scale \pde, lattice, etc.
%\item    Use \texttt{bbgen()} if the microsolver is a standard solver, \texttt{ode45} e.g., and needs to be converted into a black-box.
\item    Use \texttt{cmdc()} as a wrapper for the microsolver if the slow variables would otherwise change significantly over the microsolver.
\end{itemize}};

    \node[block, right=2ex of setmicro] (setmacro){\textbf{Set macrosolver, define problem}\\[1ex]
        \begin{tikzpicture}
    \node [tinyblock]%, below=0.6cm of pig]
     (pirk) {\textbf{If using \texttt{PIRKn()}:}
      
    Set the vector of output times \texttt{tspan}. Intervals between times are the projective time-steps. Set initial values \texttt{x0}.};
   \node [tinyblock, right=1ex of pirk]%, below right=0.2cm and -1cm of lift]
    (pig) {\textbf{If using \texttt{PIG()}:}
     
    Set the solver \texttt{macro.solver} to be used on the macro scale. Set any needed time inputs or time-step data in \texttt{macro.tspan}. Set initial values \texttt{x0}.};
    \end{tikzpicture}
    };
   
       \node [smallblock, below=2ex of setmacro] (lift) 
       {\textbf{Set lifting\slash restriction}\quad
    If needed, set functions \texttt{restrict()} and \texttt{lift()} to convert between macro and micro problems\slash variables. These are optional arguments to the Projective Integration functions.};
    
 \node [block, below right=5ex and -9\WD of setmicro] (dopi) {\textbf{Do Projective Integration}\quad 
    Invoke the appropriate Projective Integration function as, e.g., 
    \verb|[t,x]=PIRK2(solver,tspan,x0,bT)|, or
    \verb|[t,x]=PIG(solver,macro,x0)|. 
    Additional optional outputs inform you of the microscale.};
             \path [line, thick] (setmicro) to[out=-90,in=120] (dopi);
         \path [line, thick] (lift) to[out=180,in=3] (dopi);
         \path [line, thick] (setmacro) to[out=-150,in=30] (dopi);
%          \path [line, thick] (pig) to[out=180,in=0] (dopi);
%          \path [line, thick] (pirk) to[out=180,in=0] (dopi);
%          \draw [dashed, very thick] (pig) -- (pirk);
    \end{tikzpicture}
    };   
\end{tikzpicture}
\end{figure}










\begin{figure}
\centering
\caption{\label{fig:PIchoosemacro}The Projective Integration method greatly accelerates simulation\slash integration of a system exhibiting multiple time scales.
In conjunction with \cref{fig:constructPI}, this chart roughly guides which top-level Projective Integration functions should be used.
\cref{sec:ProjInt} fully details each function.}
\setlength{\WD}{0.081\linewidth}%%%%%%%%%%%%%%%%
\begin{tikzpicture}[node distance = 0.5cm, auto]
\tikzstyle{bigblock} = [rectangle, draw, thick,   text badly centered, 
    text width=12\WD, rounded corners, minimum height=2em]
\tikzstyle{block} = [rectangle, draw=red!80!black, thick, anchor=west, fill=white,
    text width=5\WD, rounded corners, minimum height=4em, text ragged]
 \tikzstyle{smallblock} = [rectangle, draw=red!80!black, thick, anchor=west, fill=white,
    text width=3.4\WD, rounded corners, minimum height=4em, text ragged]  
 \tikzstyle{yesblock} = [rectangle, draw=red!80!black, thick, anchor=west, fill=white,
    text width=1.2\WD, rounded corners, minimum height=1.2em]   
\tikzstyle{line} = [draw, -latex']
\tikzstyle{lined} = [draw, latex'-latex']
\node [bigblock,draw=red!80!black,fill=red!10] (gaptooth) {\textbf{Choosing the macro solver in Projective Integration}\\[2ex]
    \begin{tikzpicture}[node distance = 4ex, auto]
    \node [block,right=5\WD] (timestep) {{Is an appropriate time-step known for the slow dynamics?}};
    \node [yesblock, below =2ex of timestep] (timeyes) {Yes};
    \node [yesblock, right=2ex of timestep] (timeno) {No};
    \node [block, below=2ex of timeyes] (slowsol) {{Is a specific solver desired to simulate the slow dynamics?}};
     \node [smallblock, below right=2ex and 2ex of timeno] (pig) {Choose \texttt{PIG()} to simulate\slash integrate};
         \node [yesblock, below =2ex of slowsol] (slowno) {No};
    \node [yesblock,  right=2ex of slowsol] (slowyes) {Yes};
         \node [block, below =2ex of slowno] (pirk) {Choose \texttt{PIRK2()} or \texttt{PIRK4()} to  simulate\slash integrate};
         \path [line, thick] (timestep) to[out=-90,in=90] (timeyes);
         \path [line, thick] (timestep) to[out=0,in=180] (timeno);
          \path [line, thick] (timeno) to[out=0,in=90] (pig);
          \path [line, thick] (timeyes) to[out=-90,in=90] (slowsol);
          \path [line, thick] (slowsol) to[out=0,in=180] (slowyes);
          \path [line, thick] (slowsol) to[out=-90,in=90] (slowno);
          \path [line, thick] (slowno) to[out=-90,in=90] (pirk);
          \path [line, thick] (slowyes) to[out=0,in=-90] (pig);
    \end{tikzpicture}
    };   
\end{tikzpicture}
\end{figure}














\begin{figure}
\begin{maxipage}
\setlength{\WD}{0.048\linewidth}%%%%%%%%%%%%%%%%
\centering
\caption{\label{fig:constructpatch}The Patch methods, \cref{sec:patch}, accelerate simulation\slash integration of multiuscale systems with interesting spatial (or network) structure\slash patterns. The patch methods use your given microsimulators whether coded from \textsc{pde}s, lattice systems, or agent\slash particle microscale simulators.
The patch functions require that a user configure the patches, and interface the coupled patches with a time integrator\slash simulator. 
This chart overviews the main functions involved and their interrelationships.
}
\begin{tikzpicture}[node distance = 3ex, auto]
\tikzstyle{bigblock} = [rectangle, draw, thick, text width=20.5\WD, text badly centered, rounded corners, minimum height=4ex]
\tikzstyle{block} = [rectangle, draw=blue!80!black, thick, anchor=west, fill=white,
    text width=10\WD, text ragged, rounded corners, minimum height=8ex]
 \tikzstyle{smallblock} = [rectangle, draw=blue!80!black, thick, anchor=west, fill=white,
    text width=6\WD, text ragged, rounded corners, minimum height=8ex]   
 \tikzstyle{tinyblock} = [rectangle, draw=blue!80!black, thick, anchor=west, fill=white,
    text width=4.5\WD, text ragged, rounded corners, minimum height=8ex]      
\tikzstyle{line} = [draw, -latex']
\tikzstyle{lined} = [draw, latex'-latex']
\node [bigblock,draw=blue!80!black,fill=blue!10] (gaptooth) {\textbf{Patch scheme for \textsc{pde}s}\\[1ex]
    \begin{tikzpicture}[node distance = 3ex, auto]
    \node [block] (configPatches) {\textbf{Define problem and construct patches}
    
    Invoke \texttt{configpatches1} (for 1D) or \texttt{configpatches2} (for 2D) to define the microscale problem (\textsc{pde}, domain, boundary conditions, etc) and the desired patch structure (number of patches, patch size, coupling order, etc).
These functions initialise the global struct \texttt{patches}. 
The components of \texttt{patches} contain all information required to solve the microscale problem within each patch. 
If necessary, define additional components for struct \texttt{patches} (e.g., see \texttt{EnsembleAverageExample.m}).};
    \node [block, below=of configPatches] (microPDE) {\textbf{Solve microscale problem within each patch}\\
    Call the \textsc{pde} solver which is to evaluate the microscale problem within each patch. This solver may be a Matlab defined function (such as \texttt{ode15s} or \texttt{ode45}) or a user defined function (such as Runge--Kutta).
    
    Input of the \textsc{pde} solver is the function \texttt{patchSmooth1} (for 1D) or \texttt{patchSmooth2} (for 2D) which  interfaces with the \textsc{pde} solver and the microscale \textsc{pde}. Other inputs are the time span and initial conditions. Output of the \textsc{pde} solver is the solution of the patch \textsc{pde} over the given time span, but only evaluated within the defined patches.};
    \node [smallblock, above right=-2.2\WD and 2\WD of microPDE] (patchSmooth1) {\textbf{Interface to time integrators}
    
    The \textsc{pde} function (\texttt{patchSmooth1} or \texttt{patchSmooth2}) interfaces with the \textsc{pde} solve, the microscale \textsc{pde} and the patch coupling conditions. Input is the \textsc{pde} field at one time-step and output is the field at the next time-step.};
    \node [tinyblock, below left=3ex and -3\WD of patchSmooth1] (coupling) {\textbf{Coupling conditions}
    
    Coupling conditions are evaluated in \texttt{patchEdge1} (for 1D) or \texttt{patchEdge2} (for 2D) with the coupling order defined by global struct component \texttt{patches.ordCC}.};
    \node [tinyblock, below right=3ex and -3\WD of patchSmooth1] (micropde) {\textbf{Microscale \textsc{pde}}
    
    This \textsc{pde} is defined by the global struct \texttt{patches}, for example component \texttt{patches.fun} defines the function (e.g.,  \texttt{BurgersPDE} or \texttt{heteroDiff}) and \texttt{patches.x} defines the domain of the patches};
    \node [block,draw=red!80!black,fill=red!10, below=of microPDE] (pi) {\hyperref[fig:constructPI]{\textbf{\textbf{Projective integration scheme (if needed)}}}\\
    };    
    \path [lined,very thick,-latex] (configPatches) -- (microPDE);
    \path [lined,very thick] (microPDE) to[out=0,in=180] (patchSmooth1);
    \path [lined,very thick] (patchSmooth1) to[out=270,in=90] (coupling);
    \path [lined,very thick] (patchSmooth1) to[out=270,in=90] (micropde);
    \path [lined,very thick,latex-latex] (microPDE) -- (pi);
    \end{tikzpicture}
    };   
\node [bigblock,draw=black,below=of gaptooth] (process) {\textbf{Process results and plot}};
 \path [lined,very thick,-latex] (gaptooth) -- (process);
\end{tikzpicture}
\end{maxipage}
\end{figure}





%\chapter{Overview of major functions and example scripts}
%\label{sec:smf}
%\localtableofcontents
%
%{% excluding the body gives overview of each function/script
%    \renewcommand{\label}[1]{}%
%    \let\section\section%
%    \let\section\subsection%
%    \let\subsection\paragraph%
%    \let\paragraph\subparagraph%
%    \fancyvrbStartStop%
%    \excludeversion{devMan}
%    \input{../ProjInt/projInt}
%    \input{../Patch/patch}
%    \includeversion{devMan}
%}%end-exclusion

