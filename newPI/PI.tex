% input *.m files for Projective Integration  AJR, Oct 2017
%!TEX root = ../equationFreeDoc.tex
\section{Projective integration of deterministic ODEs}
\label{sec:newPI}

This is a very first stab at a good projective integration function \cite[e.g.]{Gear02b, Gear03c, Givon06}. The goal is to enable computationally expensive simulations to be run on long time scales.

Suppose the user has a `microsolver', a term we use to refer to an accurate, fine scale simulation of some interesting quantity. We assume that over the microsolver it is known that variables undergo a rapid transient onto an invariant slow manifold. 

The PI section of this toolbox consists of several functions. Each approximates a standard numerical method over the slow time scale. Each function has standardised inputs and outputs.

\paragraph{Main functions}
\begin{itemize}
\item PI by second or fourth order Runge-Kutta - \verb|PIRK2()| and \verb|PIRK4()| respectively. These schemes are suitable for precise simulation of the slow dynamics, provided the time period spanned by an application of the microsolver is not too large.
\item PI with a General solver - \verb|PIG()|. This function enables a PI implementation of any solver with coarse scale time steps. It does not matter whether the solver is a standard Matlab or Octave algorithm, or one supplied by the user. As explored in later examples, \verb|PIG()| should only be used in very stiff systems. 
\end{itemize}
The above functions share dependence on a user-specified `microsolver', that accurately simulates some problem of interest. 
\paragraph{Minor functions}
\begin{itemize}
\item "Constraint-defined manifold computing", \verb|cdmc()|. This helper function, based on the method introduced in \cite{GearKevrekidis05}, will iteratively apply the microsolver and project the output backwards in time. The result is to constrain the fast variables close to the slow manifold, without advancing the current time by the duration of an application of the microsolver. This function can be used to reduce errors related to the simulation length of the microsolver in either the \verb|PIRK| or \verb|PIG| functions. In particular, it enables \verb|PIG()| to be used on problems that are not particularly stiff.
\item Black box microsolver generator, \verb|bbm()|. This simple function takes as input a standard solver with a recommended time step for microscale simulation, and returns a `black box' microsolver for the PI functions.
\end{itemize}

The following sections describe the \verb|PIRK2()| and \verb|PIG()| functions in detail, providing an example for each. Descriptions for the minor functions follow, and an example of the use of \verb|cdmc()|. \verb|PIRK4()| (which is very similar to \verb|PIRK2()|) concludes the chapter.

\input{newPI/PIRK2.m}
\input{newPI/PIRK_Example.m}
\input{newPI/PIG.m}
\input{newPI/PIG_Example.m}

\subsection{Minor functions}
\label{sec:extras}
\input{newPI/cdmc.m}
\input{newPI/bbgen.m}

\input{newPI/PIG_Explore.m}

The guide for \verb|PIRK4()| now follows.
\input{newPI/PIRK4.m}





\section{To do/discuss}
\begin{itemize}
\item could implement PI by `arbitrary' Runge-Kutta scheme; i.e. by having the user input a particular Butcher table
\item can `reverse' the order of projeciton and microsolver applications. The output at each user-requested coarse time would then be the end point of an application of the microsolver.
\item some kind of minimally invasive checking is needed to ensure the burst length of the microsolver does not make the PI scheme redundant. E.g. for systems that are not too stiff and for a fourth order PI scheme PIRK4, we should check that four applications of the microsolver do not bridge the gap between user-specified times.
\item separate subsection for microsolver requirements? Then can point to it in each other function.
\item Can maybe implement microsolvers that terminate a burst when the fast dynamics have settles using e.g. the 'Events' function handle in ode23. 
\end{itemize}

